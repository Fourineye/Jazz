<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>jazz.camera API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jazz.camera</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from random import randint

import pygame

from .global_dict import GAME_GLOBALS
from .utils import Rect, Vec2, clamp


class Camera:
    &#34;&#34;&#34;Class that handles the drawing of objects onto the display.&#34;&#34;&#34;

    STRICT = 0
    SMOOTH = 1

    def __init__(self):
        self.display = pygame.display.get_surface()
        self._bg_color = (0, 0, 0)
        self._blanking = True
        self.target = None
        self.bounds = None
        self.follow_type = self.STRICT
        self.offset = Vec2()
        self.shake = Vec2()
        self.magnitude = 0
        self.damping = 0.1
        self.display_center = (
            self.display.get_width() / 2,
            self.display.get_height() / 2,
        )
        self.zoom = 1
        self.debug = False

    def update(self, _delta):
        &#34;&#34;&#34;
        Called every frame to update the offset and shake values

        Args:
            _delta (float): For Engine compatibility. Unused.
        &#34;&#34;&#34;
        if self.target:
            self.update_offset()
        if self.magnitude &gt; 0.1:
            self.magnitude -= self.magnitude * self.damping
            self.shake = Vec2(
                self.magnitude * randint(-10, 10), self.magnitude * randint(-10, 10)
            )
        else:
            self.shake = Vec2()
            self.magnitude = 0

    def render(self):
        draw_objects = list(GAME_GLOBALS[&#34;Scene&#34;].values())
        draw_objects.sort(key=lambda obj: obj._z, reverse=False)

        if self._blanking:
            self.display.fill(self._bg_color)
        [
            (
                obj.draw(
                    self.display,
                    (self.offset + self.shake) if not obj.screen_space else None,
                ),
                obj.debug_draw(
                    self.display,
                    (self.offset + self.shake) if not obj.screen_space else None,
                )
                if self.debug
                else None,
            )
            if obj.visible
            else None
            for obj in draw_objects
        ]
        if self.zoom &gt; 1:
            zoomed_display = self.display.copy()
            zoomed_display = pygame.transform.scale_by(zoomed_display, self.zoom)
            blit_pos = (
                self.display_center[0] - zoomed_display.get_width() / 2,
                self.display_center[1] - zoomed_display.get_height() / 2,
            )
            self.display.blit(zoomed_display, blit_pos)

    def update_offset(self):
        &#34;&#34;&#34;Updates the Camera offset to the target.&#34;&#34;&#34;
        if self.target is None:
            return
        offset_x, offset_y = self.offset
        if isinstance(self.target, Vec2):
            target_x = self.target.x
            target_y = self.target.y
        else:
            target_x, target_y = self.target.pos

        if self.follow_type == self.STRICT:
            offset_x = self.display_center[0] - target_x
            offset_y = self.display_center[1] - target_y
        elif self.follow_type == self.SMOOTH:
            offset_x += (self.display_center[0] - target_x - offset_x) / 5
            offset_y += (self.display_center[1] - target_y - offset_y) / 5

        if self.bounds is not None:
            offset_x = clamp(
                offset_x,
                -self.bounds.right + self.display.get_width(),
                -self.bounds.left,
            )
            offset_y = clamp(
                offset_y,
                -self.bounds.bottom + self.display.get_height(),
                -self.bounds.top,
            )

        self.offset.update(offset_x, offset_y)

    def set_offset(self, position=(0, 0)):
        &#34;&#34;&#34;Sets the camera offset to a specified value

        Args:
            position (tuple, optional): New offset to set the Camera to. Defaults to (0, 0).
        &#34;&#34;&#34;
        offset_x = self.display_center[0] - position[0]
        offset_y = self.display_center[1] - position[1]
        self.offset.update(offset_x, offset_y)

    def set_target(self, target):
        &#34;&#34;&#34;
        Sets the target of the Camera, which it will follow.

        Args:
            target (Entity, Vec2): The target to follow.
        &#34;&#34;&#34;
        if isinstance(target, Vec2):
            self.target = target
        elif isinstance(target, object):
            self.target = target
        else:
            print(&#34;Target must either be a Vec2 or an Entity&#34;)

    def set_bounds(self, bounds):
        if len(bounds) != 4:
            print(&#34;Bounds must be pygame rect or a iterable with length 4&#34;)
        if isinstance(bounds, pygame.Rect):
            self.bounds = bounds
        else:
            self.bounds = pygame.Rect(*bounds)

    def set_bg_color(self, color):
        self._bg_color = color

    def add_shake(self, magnitude):
        &#34;&#34;&#34;
        Adds magnitude to the Camera shake.

        Args:
            magnitude (float): The magnitude of the shake to add.
        &#34;&#34;&#34;
        self.magnitude = magnitude
        self.shake = Vec2()

    def draw_check(self, obj, debug=False):
        draw = hasattr(obj, &#34;debug_draw&#34;) if debug else hasattr(obj, &#34;draw&#34;)
        return draw and getattr(obj, &#34;visible&#34;, True)

    @property
    def pos(self):
        return self.display_center - self.offset

    @property
    def screen_rect(self):
        return Rect(
            *(-self.offset), self.display.get_width(), self.display.get_height()
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jazz.camera.Camera"><code class="flex name class">
<span>class <span class="ident">Camera</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that handles the drawing of objects onto the display.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Camera:
    &#34;&#34;&#34;Class that handles the drawing of objects onto the display.&#34;&#34;&#34;

    STRICT = 0
    SMOOTH = 1

    def __init__(self):
        self.display = pygame.display.get_surface()
        self._bg_color = (0, 0, 0)
        self._blanking = True
        self.target = None
        self.bounds = None
        self.follow_type = self.STRICT
        self.offset = Vec2()
        self.shake = Vec2()
        self.magnitude = 0
        self.damping = 0.1
        self.display_center = (
            self.display.get_width() / 2,
            self.display.get_height() / 2,
        )
        self.zoom = 1
        self.debug = False

    def update(self, _delta):
        &#34;&#34;&#34;
        Called every frame to update the offset and shake values

        Args:
            _delta (float): For Engine compatibility. Unused.
        &#34;&#34;&#34;
        if self.target:
            self.update_offset()
        if self.magnitude &gt; 0.1:
            self.magnitude -= self.magnitude * self.damping
            self.shake = Vec2(
                self.magnitude * randint(-10, 10), self.magnitude * randint(-10, 10)
            )
        else:
            self.shake = Vec2()
            self.magnitude = 0

    def render(self):
        draw_objects = list(GAME_GLOBALS[&#34;Scene&#34;].values())
        draw_objects.sort(key=lambda obj: obj._z, reverse=False)

        if self._blanking:
            self.display.fill(self._bg_color)
        [
            (
                obj.draw(
                    self.display,
                    (self.offset + self.shake) if not obj.screen_space else None,
                ),
                obj.debug_draw(
                    self.display,
                    (self.offset + self.shake) if not obj.screen_space else None,
                )
                if self.debug
                else None,
            )
            if obj.visible
            else None
            for obj in draw_objects
        ]
        if self.zoom &gt; 1:
            zoomed_display = self.display.copy()
            zoomed_display = pygame.transform.scale_by(zoomed_display, self.zoom)
            blit_pos = (
                self.display_center[0] - zoomed_display.get_width() / 2,
                self.display_center[1] - zoomed_display.get_height() / 2,
            )
            self.display.blit(zoomed_display, blit_pos)

    def update_offset(self):
        &#34;&#34;&#34;Updates the Camera offset to the target.&#34;&#34;&#34;
        if self.target is None:
            return
        offset_x, offset_y = self.offset
        if isinstance(self.target, Vec2):
            target_x = self.target.x
            target_y = self.target.y
        else:
            target_x, target_y = self.target.pos

        if self.follow_type == self.STRICT:
            offset_x = self.display_center[0] - target_x
            offset_y = self.display_center[1] - target_y
        elif self.follow_type == self.SMOOTH:
            offset_x += (self.display_center[0] - target_x - offset_x) / 5
            offset_y += (self.display_center[1] - target_y - offset_y) / 5

        if self.bounds is not None:
            offset_x = clamp(
                offset_x,
                -self.bounds.right + self.display.get_width(),
                -self.bounds.left,
            )
            offset_y = clamp(
                offset_y,
                -self.bounds.bottom + self.display.get_height(),
                -self.bounds.top,
            )

        self.offset.update(offset_x, offset_y)

    def set_offset(self, position=(0, 0)):
        &#34;&#34;&#34;Sets the camera offset to a specified value

        Args:
            position (tuple, optional): New offset to set the Camera to. Defaults to (0, 0).
        &#34;&#34;&#34;
        offset_x = self.display_center[0] - position[0]
        offset_y = self.display_center[1] - position[1]
        self.offset.update(offset_x, offset_y)

    def set_target(self, target):
        &#34;&#34;&#34;
        Sets the target of the Camera, which it will follow.

        Args:
            target (Entity, Vec2): The target to follow.
        &#34;&#34;&#34;
        if isinstance(target, Vec2):
            self.target = target
        elif isinstance(target, object):
            self.target = target
        else:
            print(&#34;Target must either be a Vec2 or an Entity&#34;)

    def set_bounds(self, bounds):
        if len(bounds) != 4:
            print(&#34;Bounds must be pygame rect or a iterable with length 4&#34;)
        if isinstance(bounds, pygame.Rect):
            self.bounds = bounds
        else:
            self.bounds = pygame.Rect(*bounds)

    def set_bg_color(self, color):
        self._bg_color = color

    def add_shake(self, magnitude):
        &#34;&#34;&#34;
        Adds magnitude to the Camera shake.

        Args:
            magnitude (float): The magnitude of the shake to add.
        &#34;&#34;&#34;
        self.magnitude = magnitude
        self.shake = Vec2()

    def draw_check(self, obj, debug=False):
        draw = hasattr(obj, &#34;debug_draw&#34;) if debug else hasattr(obj, &#34;draw&#34;)
        return draw and getattr(obj, &#34;visible&#34;, True)

    @property
    def pos(self):
        return self.display_center - self.offset

    @property
    def screen_rect(self):
        return Rect(
            *(-self.offset), self.display.get_width(), self.display.get_height()
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="jazz.camera.Camera.SMOOTH"><code class="name">var <span class="ident">SMOOTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="jazz.camera.Camera.STRICT"><code class="name">var <span class="ident">STRICT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="jazz.camera.Camera.pos"><code class="name">var <span class="ident">pos</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pos(self):
    return self.display_center - self.offset</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.screen_rect"><code class="name">var <span class="ident">screen_rect</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def screen_rect(self):
    return Rect(
        *(-self.offset), self.display.get_width(), self.display.get_height()
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jazz.camera.Camera.add_shake"><code class="name flex">
<span>def <span class="ident">add_shake</span></span>(<span>self, magnitude)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds magnitude to the Camera shake.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>magnitude</code></strong> :&ensp;<code>float</code></dt>
<dd>The magnitude of the shake to add.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shake(self, magnitude):
    &#34;&#34;&#34;
    Adds magnitude to the Camera shake.

    Args:
        magnitude (float): The magnitude of the shake to add.
    &#34;&#34;&#34;
    self.magnitude = magnitude
    self.shake = Vec2()</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.draw_check"><code class="name flex">
<span>def <span class="ident">draw_check</span></span>(<span>self, obj, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_check(self, obj, debug=False):
    draw = hasattr(obj, &#34;debug_draw&#34;) if debug else hasattr(obj, &#34;draw&#34;)
    return draw and getattr(obj, &#34;visible&#34;, True)</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self):
    draw_objects = list(GAME_GLOBALS[&#34;Scene&#34;].values())
    draw_objects.sort(key=lambda obj: obj._z, reverse=False)

    if self._blanking:
        self.display.fill(self._bg_color)
    [
        (
            obj.draw(
                self.display,
                (self.offset + self.shake) if not obj.screen_space else None,
            ),
            obj.debug_draw(
                self.display,
                (self.offset + self.shake) if not obj.screen_space else None,
            )
            if self.debug
            else None,
        )
        if obj.visible
        else None
        for obj in draw_objects
    ]
    if self.zoom &gt; 1:
        zoomed_display = self.display.copy()
        zoomed_display = pygame.transform.scale_by(zoomed_display, self.zoom)
        blit_pos = (
            self.display_center[0] - zoomed_display.get_width() / 2,
            self.display_center[1] - zoomed_display.get_height() / 2,
        )
        self.display.blit(zoomed_display, blit_pos)</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.set_bg_color"><code class="name flex">
<span>def <span class="ident">set_bg_color</span></span>(<span>self, color)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_bg_color(self, color):
    self._bg_color = color</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.set_bounds"><code class="name flex">
<span>def <span class="ident">set_bounds</span></span>(<span>self, bounds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_bounds(self, bounds):
    if len(bounds) != 4:
        print(&#34;Bounds must be pygame rect or a iterable with length 4&#34;)
    if isinstance(bounds, pygame.Rect):
        self.bounds = bounds
    else:
        self.bounds = pygame.Rect(*bounds)</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.set_offset"><code class="name flex">
<span>def <span class="ident">set_offset</span></span>(<span>self, position=(0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the camera offset to a specified value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>New offset to set the Camera to. Defaults to (0, 0).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_offset(self, position=(0, 0)):
    &#34;&#34;&#34;Sets the camera offset to a specified value

    Args:
        position (tuple, optional): New offset to set the Camera to. Defaults to (0, 0).
    &#34;&#34;&#34;
    offset_x = self.display_center[0] - position[0]
    offset_y = self.display_center[1] - position[1]
    self.offset.update(offset_x, offset_y)</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.set_target"><code class="name flex">
<span>def <span class="ident">set_target</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the target of the Camera, which it will follow.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>Entity, Vec2</code></dt>
<dd>The target to follow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_target(self, target):
    &#34;&#34;&#34;
    Sets the target of the Camera, which it will follow.

    Args:
        target (Entity, Vec2): The target to follow.
    &#34;&#34;&#34;
    if isinstance(target, Vec2):
        self.target = target
    elif isinstance(target, object):
        self.target = target
    else:
        print(&#34;Target must either be a Vec2 or an Entity&#34;)</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, _delta)</span>
</code></dt>
<dd>
<div class="desc"><p>Called every frame to update the offset and shake values</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_delta</code></strong> :&ensp;<code>float</code></dt>
<dd>For Engine compatibility. Unused.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, _delta):
    &#34;&#34;&#34;
    Called every frame to update the offset and shake values

    Args:
        _delta (float): For Engine compatibility. Unused.
    &#34;&#34;&#34;
    if self.target:
        self.update_offset()
    if self.magnitude &gt; 0.1:
        self.magnitude -= self.magnitude * self.damping
        self.shake = Vec2(
            self.magnitude * randint(-10, 10), self.magnitude * randint(-10, 10)
        )
    else:
        self.shake = Vec2()
        self.magnitude = 0</code></pre>
</details>
</dd>
<dt id="jazz.camera.Camera.update_offset"><code class="name flex">
<span>def <span class="ident">update_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the Camera offset to the target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_offset(self):
    &#34;&#34;&#34;Updates the Camera offset to the target.&#34;&#34;&#34;
    if self.target is None:
        return
    offset_x, offset_y = self.offset
    if isinstance(self.target, Vec2):
        target_x = self.target.x
        target_y = self.target.y
    else:
        target_x, target_y = self.target.pos

    if self.follow_type == self.STRICT:
        offset_x = self.display_center[0] - target_x
        offset_y = self.display_center[1] - target_y
    elif self.follow_type == self.SMOOTH:
        offset_x += (self.display_center[0] - target_x - offset_x) / 5
        offset_y += (self.display_center[1] - target_y - offset_y) / 5

    if self.bounds is not None:
        offset_x = clamp(
            offset_x,
            -self.bounds.right + self.display.get_width(),
            -self.bounds.left,
        )
        offset_y = clamp(
            offset_y,
            -self.bounds.bottom + self.display.get_height(),
            -self.bounds.top,
        )

    self.offset.update(offset_x, offset_y)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jazz" href="index.html">jazz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jazz.camera.Camera" href="#jazz.camera.Camera">Camera</a></code></h4>
<ul class="two-column">
<li><code><a title="jazz.camera.Camera.SMOOTH" href="#jazz.camera.Camera.SMOOTH">SMOOTH</a></code></li>
<li><code><a title="jazz.camera.Camera.STRICT" href="#jazz.camera.Camera.STRICT">STRICT</a></code></li>
<li><code><a title="jazz.camera.Camera.add_shake" href="#jazz.camera.Camera.add_shake">add_shake</a></code></li>
<li><code><a title="jazz.camera.Camera.draw_check" href="#jazz.camera.Camera.draw_check">draw_check</a></code></li>
<li><code><a title="jazz.camera.Camera.pos" href="#jazz.camera.Camera.pos">pos</a></code></li>
<li><code><a title="jazz.camera.Camera.render" href="#jazz.camera.Camera.render">render</a></code></li>
<li><code><a title="jazz.camera.Camera.screen_rect" href="#jazz.camera.Camera.screen_rect">screen_rect</a></code></li>
<li><code><a title="jazz.camera.Camera.set_bg_color" href="#jazz.camera.Camera.set_bg_color">set_bg_color</a></code></li>
<li><code><a title="jazz.camera.Camera.set_bounds" href="#jazz.camera.Camera.set_bounds">set_bounds</a></code></li>
<li><code><a title="jazz.camera.Camera.set_offset" href="#jazz.camera.Camera.set_offset">set_offset</a></code></li>
<li><code><a title="jazz.camera.Camera.set_target" href="#jazz.camera.Camera.set_target">set_target</a></code></li>
<li><code><a title="jazz.camera.Camera.update" href="#jazz.camera.Camera.update">update</a></code></li>
<li><code><a title="jazz.camera.Camera.update_offset" href="#jazz.camera.Camera.update_offset">update_offset</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>